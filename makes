#!/usr/bin/env python

import sys
import os
import os.path as path
import string
import subprocess
import zipfile


def find(xs, cond):
    for x in xs:
        if cond(x):
            return x
    return None


def run_cmd(cmd, directory=None):
    cur = path.abspath(os.curdir)
    if directory != None:
        os.chdir(directory)
    r = os.system(cmd);
    os.chdir(cur)
    return r


def run_cmd_with_output(cmd, directory=None):
    cur = path.abspath(os.curdir)
    if directory != None:
        os.chdir(directory)
    cmd = string.split(cmd)
    res=""
    try:
        res = subprocess.check_output(cmd)
    except:
        pass;
    os.chdir(cur)
    return res


# returns list of all targets we can build
def default_targets():
    dirs = []
    ignored = ['.git', '_build']
    for entry in os.listdir('.'):
        if os.path.isfile(entry) or entry in ignored:
            continue
        else:
            dirs.append(entry)
    return dirs


def has_ext(name, ext):
    x = path.splitext(path.basename(name))
    return len(x) == 2 and x[1] == "." + ext


def is_ml_file(name): return has_ext(name, "ml")
def is_lisp_file(name): return has_ext(name, "lisp")
def is_scm_file(name): return has_ext(name, "scm")
def dedashify(name):  return string.replace(name, "-", "_")
def chop_ext(name): return path.splitext(name)[0]
def has_opam(): return run_cmd('which opam > /dev/null') == 0
def unquote(x): return string.replace(x, "\"", "")


# When we build a plugin, we need to determine what the main file is.
# And the next steps we can take to figure out it:
# 1) main file is set by info file (no search needed then)
# 2) there is only one .ml file in target directory
# 3) there is a .ml file that has the same name as a target directory
#    (or almost same, e.g. foo-bar/foo_bar.ml, but not vice versa)
# 4) there is a .ml file that contains "main" in its name
def find_main(target):
    if target.has_key('main'):
        return target['main']
    else:
        files = os.listdir(target['path'])
        files = filter(is_ml_file, files)
        if files == []: return None
        if len(files) == 1: return files[0]
        else:
            same1 = find(files, lambda f: chop_ext(f) == target['name'])
            same2 = find(files, lambda f: chop_ext(f) == dedashify(target['name']))
            mainf = find(files, lambda f: string.find(f, "main") != -1 )
            return find([same1,same2,mainf], lambda f: f != None)


# TODO: need to add some output in case of errors
def build_ml_target(target):
    pkgs = ""
    for d in target['deps']:
        pkgs += " -pkg " + d
    print "%s: %s" % (target['name'], pkgs)
    main = find_main(target)
    if main == None:
        return 1
    else:
        plugin = path.splitext(main)[0] + ".plugin"
        cmd = "bapbuild %s %s" % (pkgs, plugin)
        r = run_cmd(cmd, target['path'])
        run_cmd('bapbundle update -desc \"%s\" %s' % (target['descr'], plugin), target['path'])
        return r


# parse recipes.scm and collect all the recipes names that it extends
def find_recipe_extends(recipe):
    exts = []
    if path.exists(recipe):
        f = open(recipe)
        lines = f.readlines()
        f.close()
        for line in lines:
            fields = string.splitfields(string.strip(line), "extend", maxsplit=1)
            if len(fields) < 2: continue
            else:
                e = string.strip(fields[1])
                e = string.strip(e, ")")
                exts.append(e)
    return exts


# returns True if [target] has ml files
def is_ml_target(target):
    files = os.listdir(target['path'])
    inds = [ True for i in range(len(files)) if is_ml_file(files[i]) ]
    return not (inds == [])

def parse_target(target):
    info = path.join(target, "info")
    recipe = path.join(target, "recipe.scm")
    full = path.join(path.abspath(os.curdir), target)
    exts = find_recipe_extends(recipe)
    x = {'name':path.basename(target), 'path':full, 'descr':"",'deps':[],'exts':exts}
    if path.exists(info):
        f = open(info)
        lines = f.readlines()
        f.close()
        for line in lines:
            fields = string.splitfields(string.strip(line), ":", maxsplit=1)
            if len(fields) < 2: continue
            elif string.strip(fields[0]) == "main":
                x['main'] = string.strip(fields[1])
            elif string.strip(fields[0]) == "descr":
                x['descr'] = string.strip(fields[1])
            elif string.strip(fields[0]) == "depends":
                x['deps'] = string.split(string.strip(fields[1]), ' ')
            else: continue
    x['ml_target'] = is_ml_target(x)
    return x


# usage should be like
# $: python makes test
# OR
# $: python makes test rule-42
# in the first case every possible recipe is testes
# in the second - the choosen one
def test(recipe_list):
    pass

def pack(target):
    if not path.exists(path.join(target['path'], 'recipe.scm')):
        return
    run_cmd("sh pack.sh " + target['path'])
    run_cmd("mv *.recipe " + target['path'])


def find_recipde_deps(all_targets, ml_powered_host, target, deps=[], errs=[]):
    for e in target['exts']:
        found = find(all_targets, lambda t: t['name'] == e)
        if found == None:
            errs.append('Can\'t find target ' + e)
            errs.append('Can\'t build target ' + target['name'])
            return deps, errs
        if found['ml_target'] and not ml_powered_host:
            reason = 'need build tools: bapbuild, bapbundle, ocamldep'
            errs.append('Can\'t build target %s: %s' % (e, reason))
            return deps, errs
        deps,errs = find_recipde_deps(all_targets, ml_powered_host, found, deps)
        deps.append(found)
    return deps,errs


def build(ml_powered_host, targets=[]):
    all_targets = map(parse_target, default_targets())
    targets = map(parse_target, targets)
    if targets == []:
        targets = all_targets
    seq = []
    for t in targets:
        deps,errs = find_recipde_deps(all_targets, ml_powered_host, t)
        if errs != []:
            print "skip %s:" % t['name']
            for er in errs:
                print er
            continue
        seq.append(t)
        seq += deps

    ordered = []
    seq.reverse()
    for t in seq:
        if not t in ordered:
            ordered.append(t)
    for t in ordered:
        if ml_powered_host and t['ml_target']:
            build_ml_target(t)
        pack(t)

# add description to a bundle(or on the pack stage)!
# here we do need to know destination
# and we need to get all the dependencies
# and we need to output error messages if target not found
def install(ml_powered_host, targets=[], recipe_dest=None):
    all_targets = map(parse_target, default_targets())
    targets = map(parse_target, targets)
    if targets == []:
        targets = all_targets
    if recipe_dest == None:
        recipe_dest = run_cmd_with_output('opam config var prefix')
        recipe_dest = recipe_dest.strip() + '/share/bap'
    for t in targets:
        if ml_powered_host and t['ml_target']:
            run_cmd('bapbundle install *.plugin', t['path'])
        for f in os.listdir(t['path']):
            if has_ext(f, 'recipe'):
                run_cmd('cp %s %s' % (f, recipe_dest), t['path'])

def uninstall(ml_powered_host, targets=[]):
    pass

# rm .plugin, .recipe and garbage after ml builds
def clean(ml_powered_host, targets=[]):
    all_targets = map(parse_target, default_targets())
    targets = map(parse_target, targets)
    if targets == []:
        targets = all_targets
    for t in targets:
        if ml_powered_host and t['ml_target']:
            run_cmd('bapbuild -clean', t['path'])
        run_cmd('rm -f *.recipe', t['path'])


def is_ml_powered_host():
    cmds = ['bapbuild', 'bapbundle', 'ocamldep', 'ocamlobjinfo']
    res = [i for i in range(len(cmds)) if run_cmd('which ' + cmds[i] + " > /dev/null") != 0]
    for r in res:
        print "%s not found" % cmds[r]
    return res == []


# TODO:  make an option to choose the destination
# DST=/usr/local/share/bap OR/AND cp
def install_destination():
    pass


def parse_args():
    args = sys.argv
    args.pop(0)
    if len(args) == 0:
        print 'command expected, poosible are: build, clean, install, uninstall, test'
        exit(1)
    s = ""
    for a in args:
        s = s + " " + a
    s = s.replace(',', ' ')
    start = s.find('[')
    if start  == -1:
        command = args.pop(0)
        targets = args
        return [command], targets
    else:
        finish = s.find(']', start + 1)
        if finish == -1:
            print "can't parse input: unclosed ["
            exit(1)
        commands = s[start + 1:finish]
        commands = commands.split()
        commands = map(lambda s: s.strip(), commands)
        targets = s[finish + 1:]
        targets = targets.split()
        targets = map(lambda s: s.strip(), targets)
        return commands, targets


def run_command(has_ml_power, command, targets):
    if   command == 'build': build(has_ml_power, targets)
    elif command == 'clean': clean(has_ml_power, targets)
    elif command == 'install': install(has_ml_power, targets)
    elif command == 'uninstall': uninstall(has_ml_power, targets)
    elif command == 'test': test(targets)
    else:
        print "error: unknown command %s, exiting ..." % command
        exit(1)

if __name__ == '__main__':
    commands, targets = parse_args()
    args = sys.argv
    has_ml_power = is_ml_powered_host()
    map(lambda c: run_command(has_ml_power, c, targets), commands)
